Summary:

This lab worked correctly for the sorting algorithms for MergeSort and Insertion Sort. However, I was confused about how to run the code after compiling, but after talking to some of my peers, I figured that I just had to use the make command.


Analysis:

1) The best case for insertion sort is when everything is already sorted from least to greatest and the worst case is when the numbers are sorted from greatest to least. After testing both these cases with 5 numbers, the best case results in 4 comparisons, 0 swaps, and 5 copy operations and the worst case results in 10 comparisons, 10 swaps, and 5 copy operations. With this we get the best case time compexity being O(n) and the worst case time complexity being O(n^2). For the average case, we can simply just use an array is somewhat sorted. For example, using {1,3,2,5,4}. This results in 6 comparisons, 2 swaps and, 5 copy operations which means the average time complexity is O(n^2).

2) Just like insertion sort, the best case for merge sort is when everything is already sorted from least to greatest and the worst case is when the numbers are sorted from greatest to least. After testing both these cases with 5 numbers, the best case results in 7 comparisons, 12 swaps, and 5 copy operations and the worst case results in 5 comparisons, 7 swaps, and 12 copy operations. With this we get the best and worst case time compexity both being O(n*log(n)). With this we can also assume the average case time compexity being O(n*log(n)) as regardless of the array, merge sort always has to divide and merge everything.


